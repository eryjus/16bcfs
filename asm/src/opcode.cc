//===================================================================================================================
// opcode.cc -- functions for managing the opcodes supported by the architecture
//
//      Copyright (c) 2023-2024 - Adam Clark
//      License: Beerware
//
//      Date     Tracker  Version  Description
//  -----------  -------  -------  ---------------------------------------------------------------------------------
//  2023-Feb-28  Initial  v0.0.1   Initial Version
//===================================================================================================================



#include "asm.hh"



//
// -- local members
//    -------------
OpCodes::OpCode_t *OpCodes::opcodeList[MAX_OPCODES] = { nullptr };
std::string OpCodes::enumString = "";
OpCodes *OpCodes::singleton = nullptr;



//
// -- Add a new opcode to the enum string
//    -----------------------------------
void OpCodes::AddEnum(const std::string &def, const std::string &bytes)
{
    std::string opcode = "";

    for (int i = 0; i < def.length(); i ++) {
        char ch = toupper(def[i]);

        if (ch < '0' || (ch > '9' && ch < 'A') || ch > 'Z') ch = '_';

        opcode += ch;
    }

    enumString = enumString + "    OPCODE_" + opcode + " = 0x";

    for (int i = 0; i < bytes.length(); i ++) {
        char ch = bytes[i];

        if (ch == ' ' || ch == '\t') break;

        enumString += ch;
    }

    enumString += ",\n";
};


//
// -- Output the enum constants to the opcodes file
//    ---------------------------------------------
void OpCodes::OutputEnum(void)
{
    static std::string preamble =
        "//===================================================================================================================\n"
        "// opcode.h -- This file is generated by the assembler.  Do not modify!\n"
        "//===================================================================================================================\n"
        "\n"
        "\n"
        "enum {\n";

    FILE *fp = fopen("opcodes.h", "w");

    if (!fp) {
        Messaging::Fatal("Unable to open opcodes.h", 0, 0, 0, 0);
    }

    fprintf(fp, "%s", preamble.c_str());
    fprintf(fp, "%s", enumString.c_str());
    fprintf(fp, "};\n\n");
    fclose(fp);
}



//
// -- converts a hex character to an integer number
//    ---------------------------------------------
int OpCodes::hex2int(char h)
{
    if (h >= '0' && h <= '9') return h - '0';
    if (h >= 'A' && h <= 'F') return (h - 'A') + 10;
    if (h >= 'a' && h <= 'f') return (h - 'a') + 10;

    Messaging::Fatal("Incorrect HEX character: %c", __FILE__, __LINE__, "", 0, h);

    return -1;
}


//
// -- add an opcode to the list.  opcodes can be duplicated, but later definitions will be unreachable.
//    -------------------------------------------------------------------------------------------------
void OpCodes::Add(const std::string &def, const std::string &bytes)
{
    for (int i = 0; i < MAX_OPCODES; i ++) {
        if (opcodeList[i] == nullptr) {
            opcodeList[i] = new OpCode_t(def, bytes);

            int idx = 0;
            int j;

            for (j = 0; j < bytes.length(); j ++) {
                if (bytes[j] == ' ') break;
                idx = (idx << 4) + hex2int(bytes[j]);
            }

            if (j != Binary_t::GetOrganization() / 4) {
                Messaging::Error("Machine Code does not match organization size", Parser_t::GetSourceFile(), yylineno, 0, 0);
            }

            if (opTable16[idx] == 0) opTable16[idx] = strdup(def.c_str());

            return;
        }
    }

    Messaging::Fatal("Too many opcode definitions", Parser_t::GetSourceFile(), yylineno, 0, 0);
}


//
// -- Dump all known opcodes
//    ----------------------
void OpCodes::Dump(void)
{
    for (int i = 0; i < MAX_OPCODES; i ++) {
        if (opcodeList[i] == nullptr) continue;

        Messaging::Msg("%04.4x: Opcode definition `%s` outputs bytes `%s`",
                i,
                opcodeList[i]->opcodeDef.c_str(),
                opcodeList[i]->byteStream.c_str());
    }
}


//
// -- Normalize an opcode definition to have a consistent number of spaces, trimming the front and back
//    -------------------------------------------------------------------------------------------------
std::string OpCodes::NormalizeInstruction(const std::string &line)
{
    std::string rv = "";
    int ch = 0;

    // -- start by skipping all leading blanks
    while (line[ch] == ' ' || line[ch] == '\t') ch ++;

    // -- now move in the mnemonic with a separating space
    while (line[ch] != ' ' && line[ch] != '\t') {
        if (line[ch] == 0) return rv;
        rv += line[ch ++];
    }

    rv += ' ';

    // -- the rest just needs to have any blanks dropped until the end of the input line
    while (line[ch]) {
        if (line[ch] != ' ' && line[ch] != '\t') {
            rv += line[ch];
        }

        ch ++;
    }

    if (rv[rv.length() - 1] == ' ') rv[rv.length() - 1] = 0;

    return rv;
}


//
// -- parse a number string into an integer and return its value
//    ----------------------------------------------------------
int OpCodes::ParseNumber(const std::string &s, uint64_t *val, int base)
{
    // -- TODO: add some protections into this function
    int p = 0;
    char ch;
    *val = 0;

    while (s[p]) {
        ch = tolower(s[p ++]);

        int d;

        if (ch >= '0' && ch <= '9') {
            d = ch - '0';
        } else if (ch >= 'a' && ch <= 'f') {
            d = ch - 'a' + 10;
        } else if (ch >= 'A' && ch <= 'F') {
            d = ch - 'A' + 10;
        } else {
            break;
        }

        *val = *val * base + d;
    }

    return p;
}



//
// -- Look up an opcode in the table and perform any substitution required
//    --------------------------------------------------------------------
OpCodes::OpCode_t *OpCodes::FindInstruction(const std::string &instr, uint64_t *val)
{
    for (int i = 0; i < MAX_OPCODES; i ++) {
        if (!opcodeList[i]) break;

        const char *mLoc = strstr(opcodeList[i]->opcodeDef.c_str(), "$(");


        if (mLoc == 0) {
            if (strcmp(instr.c_str(), opcodeList[i]->opcodeDef.c_str()) == 0) {
                return opcodeList[i];
            }
        } else {
            // -- get the position of the possible number in the instruction
            size_t len = mLoc - &opcodeList[i]->opcodeDef[0];
            if (strncmp(instr.c_str(), opcodeList[i]->opcodeDef.c_str(), len) != 0) continue;

            // -- a number will start with, well, a digit; anything else is not a number
            if (instr[len] < '0' || instr[len] > '9') {
                continue;
            }

            // -- well, we know we have a number to convert; what kind is it?
            int numDigits;

            if (instr[len] != '0') {
                numDigits = ParseDecimal(std::string(instr.c_str() + len), val);
            } else if (instr[len + 1] == 'b') {
                numDigits = ParseBinary(std::string(instr.c_str() + len), val);
            } else if (instr[len + 1] == 'x') {
                numDigits = ParseHex(std::string(instr.c_str() + len), val);
            } else {
                numDigits = ParseOctal(std::string(instr.c_str() + len), val);
            }

            if (strncmp(mLoc, "$(8)", 4) == 0) {
                if (strcmp(instr.c_str() + len + numDigits, opcodeList[i]->opcodeDef.c_str() + len + 4) == 0) {
                    if ((*val & 0xff) == *val) {
                        return opcodeList[i];
                    }
                } else continue;
            }

            if (strncmp(mLoc, "$(16)", 5) == 0) {
                if (strcmp(instr.c_str() + len + numDigits, opcodeList[i]->opcodeDef.c_str() + len + 5) == 0) {
                    if ((*val & 0xffff) == *val) {
                        return opcodeList[i];
                    }
                } else continue;
            }
        }
    }

    Messaging::Error("Unknown instruction: %s", Parser_t::GetSourceFile(), yylineno, 0, 0, instr.c_str());

    return nullptr;
}


//
// -- Parse an instruction from the source code and emit its binary result
//    --------------------------------------------------------------------
void OpCodes::ParseInstruction(const std::string &line)
{
    uint64_t val = 0;

    OpCode_t *instr = FindInstruction(line, &val);
    Binary_t::EmitInstruction(instr->byteStream.c_str(), val);
}



